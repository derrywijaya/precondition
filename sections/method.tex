\section{Method} \label{sec:method}

\subsection{Data Construction} \label{sec:data}
We construct a dataset from Wikipedia revision histories of person entities whose facts change between the year 2007 and 2012 (i.e., have at least one fact in YAGO KB with a start or end time in this period). We obtain Wikipedia URLs of this set of entities $P$ from YAGO and crawl their revision histories%, obtaining any revision their pages have between the year 2007 and 2012
. Given a person $p$, his Wikipedia revision history $H_p$ has a set of ordered dates $T_p$ on which revisions are made to his Wikipedia page $W_p$ (we consider a date granularity for time). Each revision $W_{p, t_p} \in H_p$ is the content of $W_p$ at date $t_p$ where $t_p \in T_p$. 

A document $d_{p, t_p}$ in our data set is the \textit{difference}\footnote[2]{a HTML document obtained by ``compare selected revisions"  functionality in Wikipedia} between any two consecutive revisions to $W_p$ that is separated by at least a single date worth of revisions i.e., $d_{p, t_p} = W_{p, \overline{t_p+2}} - W_{p, \underline{t_p}}$. Where $W_{p, \overline{t_p+2}}$ is the \textit{first} revision on date $t_p+2$ and $W_{p, \underline{t_p}}$ is the \textit{last} revision on date $t_p$ (since $W_p$ can be revised multiple times on a date). Our dataset consists of all documents $d_{p, t_p}$, $\forall t_p \in T_p,\ t \in [01/01/2007,\ 12/31/2012]$, and $\forall p \in P$; a total of 288,184 documents from revision histories of 16,909 Wikipedia entities.

%For example, Ralph McInerny's Wikipedia page was consecutively revised on the dates of 11/20/2012, 12/26/2012 and 12/29/2012. We find the difference between the last revision to his page on 11/20/2012 and the first revision to his page on 12/29/2012 (since a page can be revised multiple times in a date). This difference\footnote[2]{http://en.wikipedia.org/w/index.php?title=Ralph\_McInerny \&type=revision\&diff=530257160\&oldid=523980632}, a HTML page obtained by ``compare selected revisions"  functionality in Wikipedia, is a document in our dataset. Using this method, we obtain 288,184 documents from revision histories of 16,909 Wikipedia entities. 

Each Wikipedia revision $W_{p, t_p}$ consists of a set of infobox slots $S$ and a textual content $C$, where each slot $s \in S$ is a quadruple, $\langle s_{att}$, $s_{value}$,  $s_{start}$, $s_{end} \rangle$ containing the attribute name (non-empty), the attribute value, and the start and end time for which this attribute-value pair is valid. 

Each document in our dataset is a \textit{difference} between $W_{p, t_p+2}$ and $W_{p, t_p}$, and therefore consists of a set of infobox changes $\Delta S$ and textual changes $\Delta C$. Each slot change $\delta s \in \Delta S$ is also a quadruple %$\langle s_{att}$, $s_{value}$,  $s_{start}$, $s_{end} \rangle$ 
but has $s_{value}$,  $s_{start}$, or $s_{end}$, %whenever not empty, 
prefixed with $+$ or $-$ to indicate whether they are added or deleted in $W_{p, t_p+2}$. Similarly, each text change $\delta c \in \Delta C$ is prefixed with $+$ or $-$ to indicate whether they are added or deleted in $W_{p, t_p+2}$. For example in Figure \ref{fig:motivation}, a document $d_{kim,\ 05/23/2014} = W_{kim, 05/25/2014} - W_{kim, 05/23/2014}$ consists of slot changes: $\langle\textsc{spouse}$, \textbf{$+$}\footnotesize ``Kanye West"\normalsize,  $+$\footnotesize ``2014"\normalsize, \footnotesize`` "\normalsize$\rangle$, $\langle\textsc{partner}$, $-$\footnotesize``Kanye West"\normalsize,  $-$\footnotesize``2012-present; engaged"\normalsize, \footnotesize`` "\normalsize$\rangle$ and text changes: $+$\footnotesize``Kardashian and West were married in May 2014"\normalsize, $-$\footnotesize``She began dating West"\normalsize, $-$\footnotesize``they became engaged in October 2013"\normalsize.

For each document, we use its slot changes $\Delta S$ to label the document and its text changes $\Delta C$ as features for the document. We label documents that have $\langle s_{att}, +s_{value}, *, *\rangle \in \Delta S$ or $\langle s_{att}, *, +s_{start}, *\rangle$ $\in \Delta S$ with the label \textit{begin-}$s_{att}$ and documents that have $\langle s_{att}, *, *, +s_{end}\rangle$ $\in \Delta S$ with the label \textit{end-}$s_{att}$. The label represents the state change that happens in the document. For example, in Figure \ref{fig:motivation}, $d_{kim,\ 05/23/2014}$ is labeled with \textit{begin-spouse} and \textit{end-partner}. 

As features, for each labeled document $d_{p,t_p}$, we extract verbs (and verbs+prepositions) in $\Delta C$ whose subject (\textit{arg1}) matched its entity $p$ and whose object (\textit{arg2}) matched any of its $\delta s$ value (or vice versa). We use 90\% of our labeled documents as training and test on the remaining 10\%. The task is to predict for each document, the label of the document given its verbs features. 

%We define an infobox attribute of an entity e.g., \textsc{spouse} to \textit{begin} when a new value or a begin time is added to the attribute slot and to \textit{end} when an end time is being added to the slot. Using regular expression to detect whether a new value, a start, or an end time is being added to infobox slots of a document, we automatically label each document with ``begin-\{attribute\_name\}" or ``end-\{attribute\_name\}". So a document that contains an addition of a new value in the \textsc{spouse} slot will be labeled ``begin-spouse", while a document that contains an addition of end time in the \textsc{spouse} slot will be labeled ``end-spouse". 

\subsection{Model}
We use a Maximum Entropy (\textsc{MaxEnt}) classifier given the set of training data = \{(\textbf{v}$_{d_{\ell}}$, y)\} where \textbf{v}$_{d_{\ell}} =$ ($v_1$, $v_2$, ... $v_{|V|}$) $\in R^{|V|}$ is the $|V|$-dimensional representation of a labeled document $d_{\ell}$ i.e., counts of the verbs in the document, and $y$ is the document's label as defined in section \ref{sec:data}.

These training documents are used to estimate a set of weight vectors \{\textbf{w}$_1$, \textbf{w}$_2$, ... \textbf{w}$_{|Y|}$\}, one for each label $y$. The classifier can then be applied to classify an unlabeled document $d_{\textit{u}}$ using: 

 \begin{equation}
	p(y|\textbf{v}_{d_{\textit{u}}}) = \frac{\mathrm{exp}  (\textbf{w}_{y} \cdot \textbf{v}_{d_{\textit{u}}})}{\sum_{y'} \mathrm{exp} (\textbf{w}_{y'} \cdot \textbf{v}_{d_{\textit{u}}})} \label{eqn:maxent}
\end{equation}

\subsection{Feature Selection using Constraints}

While feature weights obtained by \textsc{MaxEnt} allow us to identify verbs that are good features for predicting a particular state change label, our distantly supervised training data is inherently noisy. %There is no guarantee that at any revision, the changed slots are related to the event being expressed in text. 
For example, when an entity's death happens, birth-related information in the infobox may also be updated. This can lead to incorrect state change prediction. While using many distantly labeled data may help%reduce the effect of noise
, improvements may be possible by leveraging constraints among infobox changes to select consistent verb features for each change. 

The constraints that we use can be categorized into: (1) mutual exclusion (mutex) constraints which indicate that mutex changes should not \textit{typically} happen at the same time e.g., the start of \textit{deathdate} is mutex with all other non-death changes. %or that the start of \textit{spouse} is mutually exclusive with the end of \textit{spouse}. 
A good \textit{base} verb for one slot change e.g., ``marry" for \textit{begin-spouse} is therefore not a good feature for other, mutex slot change \textit{end-spouse}. (2) Simultaneous constraints which indicate that simultaneous changes should \textit{typically} happen at the same time e.g., the start of \textit{birthdate} is simultaneous with the start of other birth-related changes such as \textit{birthplace}, \textit{birthname}, \textit{birthcity}. A good base verb for one slot change e.g., ``die" for \textit{deathdate} is therefore also a good feature for other, simultaneous, slot changes: \textit{deathplace}, \textit{deathcause}, etc. We compile such constraints using heuristics on the label names.%, labels that share the same prefix such as \textit{begin-birth*} have simultaneous constraints while labels that share the same suffix but different prefix such as \textit{begin-spouse} and \textit{end-spouse} or \textit{begin-yearsactive} and \textit{end-yearsactive} have mutually exclusive constraints.

Given the 